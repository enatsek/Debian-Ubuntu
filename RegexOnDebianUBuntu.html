<!DOCTYPE html> <html> <head> <meta charset="UTF-8"></head><body><H1>Regular Expressions On Debian and Ubuntu
</H1><p> <H4><a href="javascript:myFunction('Div1')">Copyright (C) 2024 Exforge exforge@x386.org
</a> </H4><div id="Div1" style="margin-left:1%;"><pre ># - This document is free text: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# any later version.
#
# - This document is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# - You should have received a copy of the GNU General Public License
# along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.
</pre> </div> </p>
<p> <H4><a href="javascript:myFunction('Div2')">0. Specs
</a> </H4><div id="Div2" style="margin-left:1%;"><pre ><B><span style="Font-Family:Verdana">#-- 0.0. Info
</B></span># - Well I know Regex is (almost) the same on every system, but this site is
# for Debian and Ubuntu, so it is named as.
<B><span style="Font-Family:Verdana">#-- 0.1. Resources:
</B></span># Book: 978-0-13-475706-3 Learning Regular Expressions by Ben Forta
# Book: 978-1-4842-3875-2 Regex Quick Syntax Reference by Zsolt Nagy
# Book: 978-1-449-31943-4Regular Expressions Cookbook by Jan Goyvaerts and Steven Levithan
</pre> </div> </p>
<p> <H4><a href="javascript:myFunction('Div3')">1. Basics
</a> </H4><div id="Div3" style="margin-left:1%;"><pre ><B><span style="Font-Family:Verdana">#-- 1.1. A string itself
</B></span># - Obviously every string is a match for itself
<code><span style="Color:DodgerBlue">go     # go
</span></code><code><span style="Color:DodgerBlue">dog    # dog
</span></code>#
<B><span style="Font-Family:Verdana">#-- 1.2. Or Operator 
</B></span># | or &lsqb;&rsqb;
<code><span style="Color:DodgerBlue">(c|b|t)ook  # cook
</span></code><code><span style="Color:DodgerBlue">(c|b|t)ook  # book
</span></code><code><span style="Color:DodgerBlue">(c|b|t)ook  # took
</span></code><code><span style="Color:DodgerBlue">&lsqb;cbt&rsqb;ook    # cook
</span></code><code><span style="Color:DodgerBlue">&lsqb;cbt&rsqb;ook    # book
</span></code><code><span style="Color:DodgerBlue">&lsqb;cbt&rsqb;ook    # took
</span></code>#
<B><span style="Font-Family:Verdana">#-- 1.3. Ranges
</B></span><code><span style="Color:DodgerBlue">&lsqb;a-z&rsqb;       # any lowercase letter
</span></code><code><span style="Color:DodgerBlue">&lsqb;A-Z&rsqb;       # any uppercase letter
</span></code><code><span style="Color:DodgerBlue">&lsqb;0-9&rsqb;       # any single digit number, including 0
</span></code><code><span style="Color:DodgerBlue">&lsqb;d-g&rsqb;       # d e f g   (just one of them)
</span></code><code><span style="Color:DodgerBlue">&lsqb;M-R&rsqb;       # M N O P Q R    (just one of them)
</span></code><code><span style="Color:DodgerBlue">&lsqb;a-zA-Z&rsqb;    # any letter (lower or uppercase)
</span></code><code><span style="Color:DodgerBlue">&lsqb;a-zA-Z0-9&rsqb; # any letter or number (single digit)
</span></code><code><span style="Color:DodgerBlue">&lsqb;0-9a-fA-F&rsqb; # a hexadecimal digit
</span></code>#
<B><span style="Font-Family:Verdana">#-- 1.4. Exception
</B></span><code><span style="Color:DodgerBlue">&lsqb;^a-z&rsqb;      # anything but not a lowercase letter
</span></code><code><span style="Color:DodgerBlue">&lsqb;^A-Z&rsqb;      # anything but not an uppercase letter
</span></code><code><span style="Color:DodgerBlue">&lsqb;^0-9&rsqb;      # anything but not a single digit number
</span></code>#
<B><span style="Font-Family:Verdana">#-- 1.5. Character Classes
</B></span><code><span style="Color:DodgerBlue">.        # Anything
</span></code><code><span style="Color:DodgerBlue">\d       # any digit
</span></code><code><span style="Color:DodgerBlue">\D       # anything other than a digit (any non-digit)
</span></code><code><span style="Color:DodgerBlue">\w       # any letter or digit (any alphanumeric character)
</span></code><code><span style="Color:DodgerBlue">\W       # anything other than letters and digits (any non-alphanumeric character)
</span></code><code><span style="Color:DodgerBlue">\s       # any whitespace including CR, LF, tab
</span></code><code><span style="Color:DodgerBlue">\S       # anything other than whitespaces
</span></code><code><span style="Color:DodgerBlue">\r       # Carriage Return (CR)
</span></code><code><span style="Color:DodgerBlue">\n       # Line Feed (LF)
</span></code><code><span style="Color:DodgerBlue">\t       # Tab
</span></code><code><span style="Color:DodgerBlue">\b       # Word boundary (start or end of a word)
</span></code>#
<B><span style="Font-Family:Verdana">#-- 1.6. Escape Characters
</B></span># - Any operator or quantifier can be escaped with \ to resemble itself
<code><span style="Color:DodgerBlue">\.       # .
</span></code><code><span style="Color:DodgerBlue">\&lsqb;       # &lsqb; 
</span></code><code><span style="Color:DodgerBlue">\&rsqb;       # &rsqb;
</span></code><code><span style="Color:DodgerBlue">\(       # (
</span></code><code><span style="Color:DodgerBlue">\)       # )
</span></code><code><span style="Color:DodgerBlue">\*       # *
</span></code><code><span style="Color:DodgerBlue">\+       # +
</span></code><code><span style="Color:DodgerBlue">\\       # \
</span></code><code><span style="Color:DodgerBlue">\.       # .
</span></code># - When used in a bracket, \ is not necessary
<code><span style="Color:DodgerBlue">&lsqb;().\&rsqb;   # ( ) . or \
</span></code></pre> </div> </p>
<p> <H4><a href="javascript:myFunction('Div4')">2. Quantifiers and Boundaries
</a> </H4><div id="Div4" style="margin-left:1%;"><pre ><B><span style="Font-Family:Verdana">#-- 2.1. * Quantifier
</B></span># - a * quantifier after a character or group means 0 or more occurences of it
<code><span style="Color:DodgerBlue">goal*          # goa goal goall goalll goallll ...
</span></code><code><span style="Color:DodgerBlue">co(me)*        # co come  comeme comememe comememe ...
</span></code><code><span style="Color:DodgerBlue">&lsqb;a-zA-Z&rsqb;*      # any string made from alphabet letters or an empty string
</span></code>#
<B><span style="Font-Family:Verdana">#-- 2.2. + Quantifier
</B></span># - a + quantifier after a character or group means 1 or more occurences of it
<code><span style="Color:DodgerBlue">goal+         # goal goall goalll goallll ...
</span></code><code><span style="Color:DodgerBlue">co(me)+       # come  comeme comememe comememe ...
</span></code><code><span style="Color:DodgerBlue">&lsqb;a-zA-Z&rsqb;+     # any string made from alphabet letters
</span></code>#
<B><span style="Font-Family:Verdana">#-- 2.3. ? Quantifier
</B></span># - a ? quantifier after a character or group means 0 or 1 occurences of it
<code><span style="Color:DodgerBlue">goal?              # goa goal
</span></code><code><span style="Color:DodgerBlue">co(me)?            # co come
</span></code><code><span style="Color:DodgerBlue">&lsqb;a-zA-Z&rsqb;&lsqb;a-zA-Z&rsqb;?  # any 1 or 2 alphabet letters
</span></code>#
<B><span style="Font-Family:Verdana">#-- 2.4. {} Quantifier
</B></span># - Could be in {m} {n,} or {p,r} forms, m, n, p, r are all whole numbers
# They come after a character or group and mean:
# exactly m occurences 
# n or more occurences
# p to r occurences
<code><span style="Color:DodgerBlue">set{3}                  # settt
</span></code><code><span style="Color:DodgerBlue">set{3,}                 # settt setttt settttt ...
</span></code><code><span style="Color:DodgerBlue">se{2,5}                 # sett settt setttt settttt
</span></code><code><span style="Color:DodgerBlue">&lsqb;a-zA-Z&rsqb;{3}&lsqb;0-9&rsqb;{1,3}   # any 3 letters followed by 1 to 3 digits
</span></code>#
<B><span style="Font-Family:Verdana">#-- 2.5. Greedy and Lazy Quantifiers
</B></span># - By default, a quantifier matches as many of characters as possible. 
# When we try the regex:
<code><span style="Color:DodgerBlue">\(.*\)
</span></code># (find anything in paranthesis) on the following 
<code><span style="Color:DodgerBlue">abc(def)ghi(jkl)mno
</span></code># instead of matching (def) and (jkl), it matches (def)ghi(jkl). This is called
# greedy matchings. So quantifiers are greedy by default.
# - To change the behaviour, that is matching the minimum, we can use the lazy
# versions of quantifiers by adding a ? to the end. Like:
<code><span style="Color:DodgerBlue">\(.*?\)
</span></code># - This regex matches (def) and (jkl), and this is called lazy matching.
# The lazy versions of the quantifiers are as follow:
<code><span style="Color:DodgerBlue">*	*?
</span></code><code><span style="Color:DodgerBlue">+	+?
</span></code><code><span style="Color:DodgerBlue">{n,}	{n,};
</span></code>#
<B><span style="Font-Family:Verdana">#-- 2.6. Word Boundary: \b
</B></span># \b denotes beginning or end of a word (characters surrounded by whitespaces).
<code><span style="Color:DodgerBlue">\bget         # words starting with get
</span></code><code><span style="Color:DodgerBlue">get\b         # words ending with get
</span></code><code><span style="Color:DodgerBlue">\bget\b       # get as a whole word
</span></code>#
<B><span style="Font-Family:Verdana">#-- 2.7. Line Boundaries: ^ and $
</B></span># ^ defines the start of a line
# $ defines the end of a line
<code><span style="Color:DodgerBlue">^Log:&lsqb;\s\w&rsqb;+       # All the lines starting with Log:
</span></code><code><span style="Color:DodgerBlue">^&lsqb;0-9&rsqb;{3}          # All the lines starting with 3 digits
</span></code><code><span style="Color:DodgerBlue">.*END$             # All the lines ending with END
</span></code><code><span style="Color:DodgerBlue">^Begin&lsqb;\s\w&rsqb;+End$  # All the lines starting with Begin and ending with End
</span></code></pre> </div> </p>
<p> <H4><a href="javascript:myFunction('Div5')">3. Subexpressions and Backreferences
</a> </H4><div id="Div5" style="margin-left:1%;"><pre >#- 3.1. Subexpressions
# - A subexpression is a group of characters or operators in paranthesis. They 
# are used to apply quantifiers to expressions.
<code><span style="Color:DodgerBlue">dis(like)         # matches dislike 
</span></code><code><span style="Color:DodgerBlue">dis(like)*        # matches dis, dislike, dislikelike, dislikelikelike, ...
</span></code><code><span style="Color:DodgerBlue">dis(like)+        # matches dislike, dislikelike, dislikelikelike, ...
</span></code><code><span style="Color:DodgerBlue">dis(like)?        # matches dis and dislike
</span></code><code><span style="Color:DodgerBlue">dis(like){2}      # matches dislikelike
</span></code><code><span style="Color:DodgerBlue">dis(like){2,}     # matches dislikelike, dislikelikelike, dislikelikelikelike, ...
</span></code><code><span style="Color:DodgerBlue">dis(like){2,4}    # matches dislikelike, dislikelikelike, dislikelikelikelike
</span></code># - Subexpressions can be nested
<code><span style="Color:DodgerBlue">log((in)|(out))   # matches login and logout
</span></code># 
<B><span style="Font-Family:Verdana">#-- 3.2. Backreferences
</B></span># - A backreference is in the format of a backslash followed by a digit, like \1 
# \2 \3. It refers to the subexpression in the relative position.
#
# - For example, the following regex matches the repeating words.
<code><span style="Color:DodgerBlue">&lsqb;\s&rsqb;+(\w+)&lsqb;\s&rsqb;+\1&lsqb;\s&rsqb;+
</span></code># &lsqb;\s&rsqb;+(\w+)&lsqb;\s&rsqb;+ matches a word, that is 1 or more whitespaces, followed by 1 
# or more characters, followed by 1 or more whitespaces. 
# - As the part (\w+) is the first subexpression in the regex, \1 matches to
# whatever it matches. So the regex matches the repeating word.
#
# - Another example would be matching repeating word couples:
<code><span style="Color:DodgerBlue">&lsqb;\s&rsqb;+(\w+)&lsqb;\s&rsqb;+(\w+)&lsqb;\s&rsqb;+\1&lsqb;\s&rsqb;+\2&lsqb;\s&rsqb;+
</span></code># - The first (\w+) will be the first word as \1, and the second one will be 
# the second word as \2.
#
# - Backreferences help a lot at find and replace operations. At the repeating 
# word example, if we want to replace repeating words to a single one, for the
# replace part we would have to write \1
</pre> </div> </p>
<p> <H4><a href="javascript:myFunction('Div6')">4. Regex Examples
</a> </H4><div id="Div6" style="margin-left:1%;"><pre ># Please consider, this examples are not perfect. You or someone else 
#   can definitely find or write better versions. 
#
<B><span style="Font-Family:Verdana">#-- 4.1. Email address   abc.def@email.duck.com.nz
</B></span><code><span style="Color:DodgerBlue">\w+&lsqb;\w\.&rsqb;*@\w+&lsqb;\w\.&rsqb;*\.\w+
</span></code># - Name Part:
# it can only start with a letter or a digit \w+
# then may follow any number of letters, digits and dots &lsqb;\w\.&rsqb;*
# then comes @
# - Domain Part:
# it can only start with a letter or digit \w+
# then may follow any number of letters, digits and dots &lsqb;\w\.&rsqb;*
# then comes . \.
# and then comes the TLD part \w+
#
<B><span style="Font-Family:Verdana">#-- 4.2. Date Format 02/02/2020  1\5\12 1-11-1995 31.12.2020
</B></span><code><span style="Color:DodgerBlue">\d{1,2}&lsqb;-\/.&rsqb;\d{1,2}&lsqb;-\/.&rsqb;\d{2,4}
</span></code># 1 or 2 digit day field \d{1,2}
# Separator - \ / or .  &lsqb;-\/.&rsqb;
# 1 or 2 digit month field \d{1,2}
# Separator - \ / or .  &lsqb;-\/.&rsqb;
# 2 to 4 digit year field  \d{2,4}
#
<B><span style="Font-Family:Verdana">#-- 4.3. IP Address  192.168.1.110   (A better one is coming too)
</B></span><code><span style="Color:DodgerBlue">(\d{1,3}\.){3}\d{1,3}
</span></code># 3 of (1 to 3 digit numbers, followed by a dot) : (\d{1,3}\.){3}
# 1 (1 to 3 digit numbers)
#
# - Actually this regex matches invalid IP addresses too, like:
#  300.288.11.11
# 
<B><span style="Font-Family:Verdana">#-- 4.4. A Better IP Adress
</B></span><code><span style="Color:DodgerBlue">(((25&lsqb;0-5&rsqb;)|(2&lsqb;0-4&rsqb;\d)|(1\d{2})|(\d{1,2}))\.)(((25&lsqb;0-5&rsqb;)|(2&lsqb;0-4&rsqb;\d)|(1\d{2})|(\d{1,2})))
</span></code></pre> </div> </p>
</pre> </div> </p>
<br /><br /><br /><script>
function myFunction(divid) {
  var x = document.getElementById(divid);
  if (x.style.display === "none") {
    x.style.display = "block";
  } else {
    x.style.display = "none";
  }
}
var i;
var str;

for (i=1; i<7; i++) {
    str = "Div" + i.toString();
    myFunction(str);
}
</script></body> </html>